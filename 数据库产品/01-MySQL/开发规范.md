# 1 命名规范

Ø 所有数据库对象名称（数据库、表、字段、索引、视图等）必须使用小写并用下划线分割；

Ø 所有数据库对象名称禁止使用mysql保留关键字，详见：

Ø http://dev.mysql.com/doc/refman/5.7/en/keywords.html

Ø 所有数据库对象命名要尽量做到见名知意；

Ø 所有存储相同数据的列名、类型、长度及注释必须相同；

Ø 所有名称使用英文单数，不可使用复数或中文拼音；

| **项目** | **命名格式**                                                 | **示例**                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据库   | db_项目/服务缩写                                             | db_crm                                                       |
| 普通表   | tb_表存储内容缩写                                            | tb_user_info                                                 |
| 临时表   | tmp_表内容缩写_序号_日期（YYMMDD）                           | tmp_userinfo_01_181109                                       |
| 备份表   | bak_原表名_序号_日期（YYMMDD）                               | bak_tb_userinfo_01_181109                                    |
| 分区     | 分区标识_分区类型（_分区段类型）_序列  l 分区标识：p  l 分区类型：r（range分区） l（list分区） h（hash分区）  l 分区段类型：做基于日期的range分区时用到，y（year按年分区） h（half year按半年分区） q（quarter按季度分区） m（month按月分区）w（week按周分区）d（day按日分区）  l 序列：可选，顺序数字 | 按季度range分区：2020年4个季：  p_r_q_202001  p_r_q _202002  p_r_q _202003  p_r_q _202004 |

# 2 基本设计规范

Ø 每个表都必须有**主键**（id），且为顺序递增的正整数；

Ø 所有表必须使用innodb存储**引擎**；

Ø 数据库、表和列的**字符集**统一使用utf8mb4；

Ø 所有的表和字段都必须添加**注释**；

Ø 所有表都必须有写库**时间**字段（create_time，类型为datatime）；

Ø 尽量控制单表不超过2000万，谨慎使用**分区表**（跨分区查询可能效率更低），建议采用**分库分表**方式管理大数据量表；

Ø 尽量做到冷热数据分离，减小表的宽度（mysql限制每张表中最多存储4096列，且每行不能超过65535字节），能有效减小磁盘IO，更有效利用缓存，避免读入无用冷数据（比如开发人员惯用select *，返回了很多无用的列），经常一起使用的列放在一个表中；

Ø 禁止在表中建立**预留字段**（无法见名知意，无法确定字段类型，修改字段类型会锁表）；

Ø 禁止在数据库中存储图片或文件等二进制数据；

Ø 禁止在线上数据库做压力测试；

Ø 禁止从开发环境、测试环境直接连生产数据库；

Ø 禁止OLTP系统创建自定义函数、存储过程等ROUTINES，逻辑处理应放在程序做处理；

# 3 字段设计规范

Ø 优先选择符合存储需要的最小**数据类型**，将字符串转化为数字类型存储，比如将IP地址转化为整数，将非负数据采用无符号整型进行存储；

Ø MySQL中varchar的长度指**字符数**，而非字节数，与其他数据库不同，比如varchar(255)=765字节，varchar字段是可变长类型，在磁盘存储时，是以数据实际长度进行存储的，但是读入内存时，为了效率，是以定义长度来占用内存的，比如定义一个varchar(255)的字段，实际存储了长度为10个字符的字段，在磁盘里存储为10*3=30字节（假设是UTF8字符集），但是在内存里却是占用255*3=765字节；

Ø 避免使用text、blob、enum数据类型；

Ø 尽可能所有列定位not null（索引null值需要额外空间，会占用更多空间；进行比较和计算式，需要对null值做特别处理）；

Ø 使用timestamp和datatime来存储日期型数据，而不要用字符串类型来存储（无法使用日期函数；更占空间；timestamp占空间最小，但是只能存储1970-01-01 00:00:01到 2038-01-19 03:14:07，其实timestamp在存储上是以int类型进行存储的，但表示为时间类型）；

Ø 财务相关的数据，必须使用decimal类型（精准浮点数，在计算时不会丢失精度；可存储比bigint更大的整数数据）；

# 4 索引设计规范

Ø 禁止主键更新（innodb是索引组织表，数据存储的逻辑顺序和主键顺序是相同的，如果更新主键可能会导致数据的移动，产生IO）；

Ø 禁止使用UUID、MD5、HASH、字符串列做主键（无法保证顺序增长，如果新加入的主键比历史主键还小，则会导致数据移动，产生IO）；

Ø where条件子句、order by 、group by 、distinct 中用到的列及多表join关联列创建索引；

Ø 索引列的顺序为从左到右，联合索引中要把区分度最高的列放在最左侧，区分度相似时，字段长度短的列放在左侧，区分度和字段长度都差不多时，使用最频繁的列放在最左侧；

Ø 避免建立重复和冗余索引；

Ø 对频繁的查询优先考虑覆盖索引，即整个查询语句中出现的所有列都建索引；

Ø 禁止使用外键约束，但关联键上一定要创建索引；

# 5 SQL开发规范

Ø 禁止更新日志表，日志表的操作应该只有insert和select，不允许delete和update日志表（日志一般比较大，delete和update操作非常耗费资源；后续的数据仓库等做数据同步时，无法依据时间戳增量同步数据）；

Ø 避免数据类型的隐式转换；

Ø 充分利用表上已存在的索引（避免使用like语句中前后双%查询条件；使用left join和not exists来优化not in操作，not in可能无法使用索引）；

Ø 程序连接不同的数据库使用不同的账号，禁止跨库查询（为数据库迁移和分库分表留下余地，降低耦合度，避免权限过大产生的安全风险）；

Ø 禁止采用select * 进行查询（消耗更多的cpu、io及网络资源；无法使用覆盖索引；可减少表结构变化带来的影响）；

Ø 禁止采用不含字段列表的insert 语句 如：insert into t values('a','b','c')，应该写成 insert into t(c1,c2,c3) values('a','b','c')，可以减少表结构变化带来的影响；

Ø 避免采用子查询，可以优化为join操作（子查询结果集无法使用索引，子查询产生临时表，消耗过多的cpu和io资源）；

Ø 避免join太多表（MySQL最大允许61张表关联，建议不超过5张）；

Ø 使用in代替or（尽量不要超过500个，in能有效利用索引）；

Ø 禁止使用order by rand()进行随机排序（会将多有符合的数据加载到内存再进行随机排序）；

Ø 禁止在where条件中对列进行函数转换（无法使用相关列上的索引，比如 where date(createtime) = '20181109' 可修改为 where createtime >= '2018-11-09' and createtime < '2018-11-10'）；

Ø 不需要去重或结果集没有重复值时，采用union all 而不要采用union；

# 6 数据库命令规范

1、所有数据库对象名称必须使用小写字母并用**下划线**分割

2、所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）

3、数据库对象的命名要能做到见名识意，并且最后不要超过32个字符

4、临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀

5、所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）

# 7 数据库基本设计规范

1、所有表必须使用 Innodb 存储引擎

没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（mysql5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好

2、数据库和表的字符集统一使用UTF8MB4

兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效

3、所有表和字段都需要添加注释

使用comment从句添加表和列的备注从一开始就进行数据字典的维护

4、尽量控制单表数据量的大小，建议控制在 500 万以内

500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题

可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小

5、谨慎使用 MySQL 分区表

分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据

6、尽量做到冷热数据分离，减小表的宽度

MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节 减少磁盘 IO, 保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大, 也会消耗更多的 IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作）

7、禁止在表中建立预留字段

预留字段的命名很难做到见名识义预留字段无法确认存储的数据类型，所以无法选择合适的类型对预留字段类型的修改，会对表进行锁定

8、禁止在数据库中存储图片，文件等大的二进制数据

通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息

9、禁止在线上做数据库压力测试

10、禁止从开发环境，测试环境直接连接生成环境数据库

# 8 数据库字段设计规范

1、优先选择符合存储需要的最小的数据类型

原因

列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多， 索引的性能也就越差 

方法

1）将字符串转换成数字类型存储，如：将 IP 地址转换成整形数据。

mysql 提供了两个方法来处理 ip 地址：

inet_aton 把 ip 转为无符号整型 (4-8 位)

inet_ntoa 把整型的 ip 转为地址

插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间。显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。

2）对于非负型的数据（如自增 ID、整型 IP）来说，要优先使用无符号整型来存储

因为：无符号相对于有符号可以多出一倍的存储空间

SIGNED INT -2147483648~2147483647

UNSIGNED INT 0~4294967295

VARCHAR(N) 中的 N 代表的是字符数，而不是字节数

使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存

**2、避免使用 TEXT、BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据**

建议把 BLOB 或是 TEXT 列分离到单独的扩展表中

Mysql 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。

而且对于这种数据，Mysql 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。

如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。

TEXT 或 BLOB 类型只能使用前缀索引

因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的。

**3、避免使用 ENUM 类型**

1、修改 ENUM 值需要使用 ALTER 语句

2、ENUM 类型的 ORDER BY 操作效率低，需要额外操作

3、禁止使用数值作为 ENUM 的枚举值

**4、尽可能把所有列定义为 NOT NULL**

原因：

1、索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；

2、进行比较和计算时要对 NULL 值做特别的处理

**5、使用 TIMESTAMP（4 个字节）或 DATETIME 类型（8 个字节）存储时间**

TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。

TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高

超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储。

经常会有人用字符串存储日期型的数据（不正确的做法）：

缺点 1：无法用日期函数进行计算和比较

缺点 2：用字符串存储日期要占用更多的空间

**6、同财务相关的金额类数据必须使用 decimal 类型**

1、非精准浮点：float,double

2、精准浮点：decimal

Decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。可用于存储比 bigint 更大的整型数据。推荐：[37 个 MySQL 数据库小技巧！](http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247487061&idx=1&sn=0dfc867eb90bb9f79d45faf3d2a470ec&chksm=eb538b63dc2402754308364cae71988ed083c85fe6b26e01ce1dda5c183065d2199c9c3912c5&scene=21#wechat_redirect)

# 9 索引设计规范  

**1、限制每张表上的索引数量，建议单张表索引不超过 5 个**

索引并不是越多越好！索引可以提高效率同样可以降低效率。

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。

因为 mysql 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 mysql 优化器生成执行计划的时间，同样会降低查询性能。

**2、禁止给表中的每一列都建立单独的索引**

5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。推荐：[MySQL 索引 B + 树原理，以及建索引的几大原则](http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247489169&idx=1&sn=5188961c066ccb5f1065e8611a8c2012&chksm=eb5393a7dc241ab1d0268266b9263053a87b4b2d2ea81b86d66d49b393d6d5f1ed09e6857a4e&scene=21#wechat_redirect)。

**3、每个 Innodb 表必须有个主键**

Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。

每个表都可以有多个索引，但是表的存储顺序只能有一种 Innodb 是按照主键索引的顺序来组织表的。

不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用 UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。

主键建议使用自增 ID 值。

# 10 常见索引列建议

1、出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列

2、包含在 ORDER BY、GROUP BY、DISTINCT 中的字段

并不要将符合 1 和 2 中的字段的列都建立一个索引，通常将 1、2 中的字段建立联合索引效果更好

3、多表 join 的关联列

# 11 如何选择索引列的顺序

建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。

1、区分度最高的放在联合索引的最左侧（区分度 = 列中不同值的数量 / 列的总行数）；

2、尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）；

3、使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。

# 12 避免建立冗余索引和重复索引

因为这样会增加查询优化器生成执行计划的时间。

**重复索引示例：**primary key(id)、index(id)、unique index(id) 

**冗余索引示例：**index(a,b,c)、index(a,b)、index(a)

  

# 13 优先考虑覆盖索引

  

对于频繁的查询优先考虑使用覆盖索引。

**覆盖索引：**就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引

覆盖索引的好处：

避免 Innodb 表进行索引的二次查询

Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，

如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。

可以把随机 IO 变成顺序 IO 加快查询效率

由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。

# 14 索引SET规范

**尽量避免使用外键约束**

1、不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引；

2、外键可用于保证数据的参照完整性，但建议在业务端实现；

3、外键会影响父表和子表的写操作从而降低性能。

# 15 数据库 SQL 开发规范

**1、建议使用预编译语句进行数据库操作**

预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题 只传参数，比传递 SQL 语句更高效 相同语句可以一次解析，多次使用，提高处理效率。推荐：[MySQL 数据库开发的 36 条军规！](http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247486173&idx=2&sn=0603756b36279b5f5f036151af85f9fd&chksm=eb538febdc2406fd70748604c500eeaea584306c137cb2020ab5a72187c9359926015e00a46d&scene=21#wechat_redirect)

**2、避免数据类型的隐式转换**

隐式转换会导致索引失效。如：select name,phone from customer where id = '111';

**3、充分利用表上已经存在的索引**

避免使用双 % 号的查询条件。

如 a like '%123%'，（如果无前置 %, 只有后置 %，是可以用到列上的索引的）

一个 SQL 只能利用到复合索引中的一列进行范围查询

如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到，在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧。

使用 left join 或 not exists 来优化 not in 操作

因为 not in 也通常会使用索引失效。

**4、数据库设计时，应该要对以后扩展进行考虑**

**5、程序连接不同的数据库使用不同的账号，进制跨库查询**

1、为数据库迁移和分库分表留出余地

2、降低业务耦合度

3、避免权限过大而产生的安全风险

**6、禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询**

原因：

1、消耗更多的 CPU 和 IO 以网络带宽资源

2、无法使用覆盖索引

3、可减少表结构变更带来的影响

**7、禁止使用不含字段列表的 INSERT 语句**

如：insert into values ('a','b','c');

应使用 insert into t(c1,c2,c3) values ('a','b','c');

**8、避免使用子查询，可以把子查询优化为 join 操作**

通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时，才可以把子查询转化为关联查询进行优化。

子查询性能差的原因：

1、子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响；

3、特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；

3、由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。

**9、避免使用 JOIN 关联太多的表**

对于 Mysql 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。

在 Mysql 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。

如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。

同时对于关联操作来说，会产生临时表操作，影响查询效率 Mysql 最多允许关联 61 个表，建议不超过 5 个。

**10、减少同数据库的交互次数**

数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率

**11、对应同一列进行 or 判断时，使用 in 代替 or**

in 的值不要超过 500 个 in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。

**12、禁止使用 order by rand() 进行随机排序**

会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。

推荐在程序中获取一个随机值，然后从数据库中获取数据的方式

**13、WHERE 从句中禁止对列进行函数转换和计算**

对列进行函数转换或计算时会导致无法使用索引。

不推荐：

where date(create_time)='20190101'

推荐：

where create_time >= '20190101' and create_time < '20190102'

**14、在明显不会有重复值时使用 UNION ALL 而不是 UNION**

1、UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作

2、UNION ALL 不会再对结果集进行去重操作

**15、拆分复杂的大 SQL 为多个小 SQL**

1、大 SQL：逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL

2、MySQL：一个 SQL 只能使用一个 CPU 进行计算

3、SQL 拆分后可以通过并行执行来提高处理效率

  

# 16 数据库操作行为规范

  

**1、超 100 万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作。**

大批量操作可能会造成严重的主从延迟

主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况

binlog 日志为 row 格式时会产生大量的日志

大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。

避免产生大事务操作

大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。

特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。

**2、对于大表使用 pt-online-schema-change 修改表结构**

1、避免大表修改产生的主从延迟

2、避免在对表字段进行修改时进行锁表

对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。

pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。

把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。

把原来一个 DDL 操作，分解成多个小的批次进行。

**3、禁止为程序使用的账号赋予 super 权限**

当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接 super 权限只能留给 DBA 处理问题的账号使用。

**4、对于程序连接数据库账号，遵循权限最小原则**

程序使用数据库账号只能在一个 DB 下使用，不准跨库 程序使用的账号原则上不准有 drop 权限。

