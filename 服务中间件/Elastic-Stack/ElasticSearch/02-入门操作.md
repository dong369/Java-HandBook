# 1 概念理解

## 1.1 是什么

Elasticsearch简称ES。

Elasticsearch VS Solr: https://www.cnblogs.com/jajian/p/9801154.html

基于Apache Lucene构建的开源搜索引擎，提供一个**分布式多用户能力的全文搜索引擎**，用Java编写的，提供简单易用的RESTFul API，当前流行的企业级搜索引擎，轻松的**横向扩展**，可支持**PB级的结构化或非结构化数据处理**，可以准实时地快速存储、搜索、分析海量的数据（用于云计算中，能够达到实时搜索）。

## 1.2 应用场景

海量数据分析引擎(聚合搜索)

站内搜索引擎

数据仓库

## 1.3 接近实时

Elasticsearch是一个接近实时（NRT）的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒）。

## 1.4 产品对比

| MySQL               | ElasticSearch         | MongoDB    |
| ------------------- | --------------------- | ---------- |
| Database            | Index                 | Database   |
| Table               | Type                  | Collection |
| Row                 | Document              | Document   |
| Column              | Field                 | Field      |
| Schema              | Mapping               |            |
| Index               | Everything is indexed |            |
| SQL                 | Query DSL             |            |
| SELECT * FROM table | GET http://…          |            |
| UPDATE table SET    | PUT http://…          |            |

Elasticsearch集群可以包含多个**索引(indices)**（数据库）。6.x之前每一个索引可以包含多个**类型(types)**（表）；但是6.x不允许一个索引包含多个类型，只能有一个；到7.x将不能创建类型，默认是_doc类型；更高版本会完全去掉类型。每一个类型包含多个**文档(documents)**（行），然后每个文档包含多个**字段(Fields)**（列）。

百货大楼里有各式各样的商品，例如书籍、笔、水果等。书籍可以根据内容划分成不同种类，如科技类、教育类、悬疑推理等。悬疑推理类的小说中比较有名气的有《福尔摩斯探案集》、《白夜行》等

百货大楼 –> Elasticsearch数据库
书籍 –> 索引
悬疑推理 –> 类型
白夜行 –> 文档

## 1.5 索引

含有相同属性的文档集合。

索引indices，含有相同属性的文档集合，可以类比关系数据库中的tables表。类型索引可以定义一个或多个类型，文档必须属于一个类型。索引中存储具有相同结构的文档（ Documen）。每个索引都有自己的mapping定义，用于定义字段名和类型，一个集群可以有多个索引。

一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（**必须全部是小写字母的**），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。索引类似于关系型数据库中Database的概念。在一个集群中，如果你想，可以定义任意多的索引。

## 1.6 类型

索引可以定义一个或多个类型，文档必须属于一个类型。

在一个索引中，你可以定义一种或多种类型（type）。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。类型类似于关系型数据库中Table的概念。

## 1.7 文档

一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON(Javascript Object Notation)格式来表示，而JSON是一个到处存在的互联网数据交互格式。

在一个index/type里面，只要你想，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须被索引/赋予一个索引的type。文档类似于关系型数据库中Record的概念。实际上一个文档除了用户定义的数据外，还包括_index、_type和_id字段。

文档document，是可以被索引的基本数据单位。Json object，由字段（ Field）组成。用户存储在ES中的数据文档。每个文档有唯的id标识（可以自行指定；也可以自动生成）。元数据，用于标注文档的相关信息。

_index：文档所在的索引名。
_type：文档所在的类型名。
_id：文档唯一id。
_uid：组合id，由ype和id组成（6.x_type不再起作用，同id—样）。
_source：文档的原始Json数据，可以从这里获取毎个字段的内容。
_all：整合所有字段内容到该字段，默认禁用，不推荐使用。

## 1.8 分片

分片每个索引都有多个分片，每个分片是一个 Lucene索引；

一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据`1TB`的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。

为了解决这个问题，`Elasticsearch`提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。

分片之所以重要，主要有两方面的原因：允许你水平分割/扩展你的内容容量；允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量。

至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由`Elasticsearch`管理的，对于作为用户的你来说，这些都是透明的。

## 1.9 备份

备份拷贝一份分片就完成了分片的备份。

在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了。这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。

复制之所以重要，主要有两方面的原因：在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的；扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行。

总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制数量，但是不能改变分片的数量。

默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制（7.x之前），这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。一个索引的多个分片可以存放在集群中的一台主机上，也可以存放在多台主机上，这取决于你的集群机器数量。主分片和复制分片的具体位置是由ES内在的策略所决定的。

## 1.10 节点

节点Node一个 Elasticsearch的运行实例，是集群的构成单元；

## 1.11 集群

集群Cluster由一个或多个节点组成，对外提供服务。一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是Elasticsearch。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。在产品环境中显式地设定这个名字是一个好习惯，但是使用默认值来进行测试/开发也是不错的。

# 2. Rest API

Elasticsearch集群对外提供 RESTful API（REST -REpresentational State Transfer）。

URI指定资源，如 Index、 Document等。

Http Method指明资源操作类型，如GET（获取）、POST（修改、更新）、PUT（新建）、 DELETE（删除）等。

注意这个Rest风格的API和Java中规定的不太一样，主要是POST和PUT的不一样！

## 2.1 交互方式

Curl命令行：语法相对不好写。

Kiana DevTools：推荐使用，带自动提示功能。

Postman：推荐使用。

## 2.2 索引操作

ES有专门的 Index API，用于创建、更新、删除索引配置等。

### 2.2.1 非结构化创建

非结构化创建语法：put http://211.144.5.80:30136/school

查看所有的indices：get http://211.144.5.80:30136/_cat/indices

查看创建后的结构：get http://211.144.5.80:30136/school        可以发现mappings中是空的！

### 2.2.2 结构化创建

结构化创建语法：put http://211.144.5.80:30136/school

```json
PUT school
{
    "settings": {
        // 分片数，创建后不能再修改
        "number_of_shards": 3,
        // 备份数，创建后是可以修改的
        "number_of_replicas": 1
    },
    "mappings": {
        // 注意外层不能指定types，7.x之前是可以指定的
        "properties": {
            "name": {
                "type": "text"
            },
            "address": {
                "type": "keyword"
            },
            "age": {
                "type": "integer"
            },
            "date": {
                "type": "date",
                "format": "yyyy-MM-dd HH:mm:ss|| yyy-MM-dd||epoch_millis"
            }
        }
    }
}
```

### 2.2.3 删除索引

删除索引语法：delete http://211.144.5.80:30136/school

## 2.3 文档操作

### 2.3.1 指定ID创建文档

语法：put http://211.144.5.80:30136/test01/doc/1   {"name":"guo","age":22}

### 2.3.2 不指定ID创建文档

语法：post http://211.144.5.80:30136/test01/doc   {"name":"guo","age":22}

### 2.3.3 查询文档

语法：get http://211.144.5.80:30136/test01/doc/1

### 2.3.4 批量创建文档

ES允许一次创建多个文档，从而减少网络传输开销，提升写入速率，endpoint为_bulk。

### 2.3.5 批量查询文档

ES允许一次查询多个文档，endpoint为_mget。

# 3 源码附录

```json
# create index
PUT /test_index

GET _cat/indices

DELETE test_index

# create document
PUT /test_index/doc/1
{
  "username": "alfred",
  "age": 1
}

# create document without id
POST /test_index/doc
{
  "username": "tom",
  "age": 20
}

# query document
GET /test_index/doc/1

# query
GET /test_index/doc/_search


GET /test_index/doc/_search
{
  "query": {
    "term": {
      "_id": "1"
    }
  }
}

GET test_index/_search

# 批量操作 bulk api
POST _bulk
{
  "index": {
    "_index": "test_index",
    "_type": "doc",
    "_id": "3"
  }
}
{
  "username": "alfred",
  "age": 20
}
{
  "delete": {
    "_index": "test_index",
    "_type": "doc",
    "_id": "1"
  }
}
{
  "update": {
    "_id": "2",
    "_index": "test_index",
    "_type": "doc"
  }
}
{
  "doc": {
    "age": "20"
  }
}

# 批量查询 multi_get
GET /_mget
{
  "docs": [
    {
      "_index": "test_index",
      "_type": "doc",
      "_id": "3"
    },
    {
      "_index": "test_index",
      "_type": "doc",
      "_id": "2"
    }
  ]
}
```







